<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="utf-8">
  <title>Running an auditor node</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="generator" content="Hugo 0.80.0" />
  
  <!-- ** CSS Plugins Needed for the Project ** -->
  
  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://docs.themelio.org/plugins/bootstrap/bootstrap.min.css">

  <!-- themefy-icon -->
  <link rel="stylesheet" href="https://docs.themelio.org/plugins/themify-icons/themify-icons.css">

  <!--Favicon-->
  <link rel="icon" href="https://docs.themelio.org/images/favicon.png" type="image/x-icon">

  <!-- fonts -->
  <link href="https://fonts.googleapis.com/css?family=Inter:300,400,700&display=swap" rel="stylesheet">
  
  <style>
  :root{
    --primary-color:#00a6b3;
    --body-color:#f9f9f9;
    --text-color:#242738;
    --text-color-dark:#242738;
    --white-color:#ffffff;
    --light-color:#f8f9fa;
  }
  </style>

<!-- Main Stylesheet -->

<link href="https://docs.themelio.org/css/style.min.css" rel="stylesheet" media="screen"/>
  
<!-- ** JS Plugins Needed for the Project ** -->

<!-- jquiry -->
<script src="https://docs.themelio.org/plugins/jquery/jquery-1.12.4.js"></script>

<!-- jquary ui -->
<script src="https://docs.themelio.org/plugins/jquery/jquery-ui.js"></script>

<!-- Bootstrap JS -->
<script src="https://docs.themelio.org/plugins/bootstrap/bootstrap.min.js"></script>

<!-- match-height JS -->
<script src="https://docs.themelio.org/plugins/match-height/jquery.matchHeight-min.js"></script>

  

  <!-- create /layouts/partials/overrides/header.html in your own theme or root directory to add your custom content here -->


</head>

  
  <body>

    <!-- header -->
    <header class="shadow-bottom sticky-top bg-white">
      <nav class="navbar py-3 navbar-expand-md navbar-light">
  <div class="container">
    <a class="navbar-brand px-2" href="/">
      
      
      
      
      <img class="img-fluid" src="https://docs.themelio.org/images/logo-icon.png" alt="Themelio knowledge base">
      
      
      Themelio knowledge base
    </a>
    <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse text-center" id="navigation">
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item">
          <a class="nav-link" href="https://themelio.org/">Home</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="https://themelio.org/resources.html">Resources</a>
        </li>
        
      </ul>

      <ul class="navbar-nav ml-auto">
        <div class="position-relative">

          <i class="ti-search search-icon"></i>
          <input id="search" class="form-control" placeholder="">
          
          
          
          
          <script>
            $(function () {
              var projects = [
                
              {
                value: "Themelio overview",
                label: "<p>What is Themelio? Themelio is a public blockchain that enables open, secure, and decentralized apps that work reliably and can\u0026rsquo;t be taken down. An example is Mel, an independent, stable-value cryptocurrency that anyone can freely use. Inspired by previous blockchains like Bitcoin and Ethereum, Themelio nontheless takes a radically different design approach inspired by that of the Internet.\nTraditional blockchains either implement one application or try to provide a comprehensive solution to all use cases—in this aspect they are like pre-Internet telecom protocols. Like those protocols, they suffer from damaging application-protocol friction. While basic infrastructure like Ethereum or the telephone network is very difficult to change once widely adopted, application requirements constantly and unpredictably evolve. This inevitably causes either poor usability, destabilizing protocol upgrades, or both, as exemplified in highly contentious blockchain hard forks like Ethereum\u0026rsquo;s DAO fork or Bitcoin\u0026rsquo;s SegWit upgrade.\nThemelio, on the other hand, is designed as a radically simple, stable, and long-term foundation that can power a vast and diverse ecosystem precisely by focusing only on the functionality that all apps need. As such, we envision Themelio to play a fundamental and uniquitous role in the security infrastructure of a new and decentralized Internet, much like IP, the protocol from 1983 that still underpins Internet communication.\n Stability: the heart of Themelio Themelio\u0026rsquo;s core mission is to serve as a stable root of endogenous trust. Endogenous trust, or trust that emerges from within the protocol rather than from its users, is the \u0026ldquo;killer feature\u0026rdquo; of blockchains. It allows us to trust the blockchain with minimal assumptions about who runs it. Endogenous trust distinguishes blockchains from all previous protocols, including decentralized and federated ones like BitTorrent and IRC. By focusing on this one key aspect of blockchains and implementing it exceptionally well, Themelio aims to support a new blockchain-rooted, multi-layered paradigm of decentralized Internet apps.\nEssential to endogenous trust is stability. Unstable protocols need regular tweaks, making \u0026ldquo;governance\u0026rdquo;—exogenous interventions in the protocol—necessary for blockchains that implement them. Unstable cryptocurrencies make securely storing and measuring value on the blockchain difficult, spawning a decentralized finance (DeFi) ecosystem heavily reliant on fiat-pegged stablecoins, oracles, and other instances of exogenous trust. Furthermore, unstable, unintuitive behavior (such as fee levels that vary wildly over time, error-prone smart contract VMs, and nondeterministic consensus) make developing secure applications that correctly leverage the blockchain\u0026rsquo;s endogenous trust rather than rely on exogenous trust in third parties surprisingly difficult. It is no surprise, then, that Themelio\u0026rsquo;s most important design decisions are focused on stability.\nStable protocol The most important pillar of Themelio\u0026rsquo;s stability is its stable protocol. Themelio\u0026rsquo;s core blockchain logic is much simpler than other general-purpose blockchains like Ethereum and Tezos. It employs a seemingly rudimentary transaction model based on spending coins, i.e., unspent transaction outputs, or UTXOs. With a small, carefully selected set of additional features, this allows Themelio to power entire application classes impossible with conventional coin-based blockchains like Bitcoin and Litecoin.\nThe two most important of these \u0026ldquo;superpowers\u0026rdquo; are MelVM and state commitments. MelVM is a non-Turing-complete virtual machine that nevertheless can compute all primitive recursive functions and enables attaching sophisticated covenants to coins. It powers on-chain protocols like tokens and financial instruments without the pitfalls of stateful smart contracts. Then, state commitments use sparse Merkle trees to commit in the block header all the information needed to validate transactions, like the set of all unspent coins. This enables scaling strategies crucial to global adoption, such as full nodes with limited storage space and thin clients that can securely verify much more information than conventional techniques like Bitcoin\u0026rsquo;s SPV allows.\nStable cryptocurrency The second pillar of Themelio\u0026rsquo;s stability is Mel, its base cryptocurrency. Mel is the first ever endogenous stablecoin: a cryptocurrency that keeps a relatively stable purchasing power without pegs to external assets like the US dollar. The purchasing power a mel is backed by Melmint, an equity-based stablecoin mechanism similar to Basis and Seigniorage Shares, with two crucial differences:\n Instead of a price oracle, we use an auction mechanism to measure the on-chain value of a day of sequential computation, or \u0026ldquo;DOSC\u0026rdquo;. The value of 1 DOSC at a given time is the cost of 24 hours of sequential computation on the fastest processor available at that time \u0026mdash; a value that maintained surprisingly stable purchasing power over the last two decades. This frees Mel entirely from trust in external oracles and fiat currency. Rather than shares backed by future stablecoin issuance, Melmint issues Sym, Themelio\u0026rsquo;s proof-of-stake token, to support the mel\u0026rsquo;s value in times of decreasing demand. This eliminates \u0026ldquo;death spiral\u0026rdquo; scenarios common in dual-token stablecoin mechanisms and guarantees Mel\u0026rsquo;s stability as a blockchain\u0026rsquo;s base currency even when issuance is expected to decline.  We\u0026rsquo;ve published Melmint as a peer-reviewed paper at Cryptoeconomic Systems 2020, and a further revised version is available here for those interested in the technical details of Melmint.\nStable behavior Finally, stable behavior during blockchain operation is crucial to developing apps that leverage endogenous trust reliably and securely. This is largely supported by Synkletos, the cryptoeconomic protocol that secures Themelio\u0026rsquo;s consensus and powers its on-chain fee economy.\nSynkletos is based on Byzantine fault-tolerant proof-of-stake consensus between \u0026ldquo;stakers\u0026rdquo; with a separate token, Sym. Sym is fixed-issuance like traditional cryptocurrencies and pays dividends from transaction fees. By using BFT consensus, Synkletos ensures that transactions are either fully confirmed or not present in the blockchain, eliminating the complex latency-dependent guesswork required in \u0026ldquo;chain-based\u0026rdquo; blockchains like Bitcoin and Ethereum when deciding whether or not to permanently trust a transaction.\nUnlike present blockchains\u0027 fee systems, Synkletos drives staker income largely from stabilized, market-determined fees rather than inflation-based block rewards. This aligns incentives between stakers and users, rendering collusion between stakers to subvert the protocol unprofitable even with a small number of stakers, while making fees much stabler and fee estimation trivial.\nYou can find a detailed treatment of Synkletos right here in this knowledge base.\n Get started now! Themelio has launched its alphanet. This gives us a proof-of-concept to tinker with that you can also participate in. At this point, development is highly agile and prioritizes flexibility over stability.\nTo get started, you can learn more about Themelio in this knowledge base, join our Discord channel, and try transacting in some placeholder \u0026ldquo;Monopoly money\u0026rdquo; with our alphanet wallet.\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/table-of-contents\/"
              },
              
              {
                value: "Themelio Yellow Paper v1",
                label: "<p>In this \u0026ldquo;yellow paper\u0026rdquo;, we discuss Themelio\u0026rsquo;s abstract model of the state of the blockchain. Themelio uses a richly-scripted coin-based model that is different from both the simple coin-based model of Bitcoin and the accounts-and-contracts model of Ethereum.\n Basic concepts Blockchains as state machines Throughout this yellow paper, we will be discussing Themelio as a transaction-based state machine, a conceptual framework introduced by the creators of Ethereum in their yellow paper. What this means is that a blockchain starts with a genesis state, which is mutated by transactions over time, finally ending at the blockchain at its current state.\nTransactions, in this model, are arcs between valid states, and only states that can be reached by repeatedly applying valid transactions to the genesis state are valid states in the blockchain. Formally, we can say that\n$$\\sigma\u0027 \\equiv \\Upsilon(\\sigma, T)$$\nwhere $\\Upsilon$ is the state transition function, $T$ is a transaction, $\\sigma$ is the state before the transaction entered the blockchain, and $\\sigma\u0027$ is the state afterwards.\nA blockchain, however, does not exactly consist of a linear history of transactions \u0026mdash; transactions are collated into blocks, each of which can contain a large number of transactions, and possibly auxiliary data. This collation process then forms a coarse-grained journal of transactions. A more accurate formalization, then, uses a block-level state transition function $\\Pi$:\n$$ \\begin{aligned} \\sigma_{i\u002b1} \u0026amp; \\equiv \\Pi(\\sigma_i, B) \\newline\\\nB \u0026amp; \\equiv (F, (T_0,T_1,\\dots)) \\newline\\\n\\Pi(\\sigma,B) \u0026amp; \\equiv \\Omega(B, \\Upsilon(\\Upsilon(\\sigma, T_0), T_1)\\dots) \\end{aligned} $$\nwhere $\\Omega$ is the block sealing function that assembles a final state out of the result of applying all the transactions $T_i$ within block $B$, in addition to a sealing event $F$ which includes per-block actions such as collecting fees.\nWe believe that treating a blockchain as fundamentally a state machine is a much more helpful model than simply a series of transactions, even for coin\/UTXO-based blockchains like Themelio. Furthermore, Themelio extensively uses explicit on-chain representations of the current blockchain state, rather than making most of the state implicit as in Bitcoin.\nA note on notation We introduced the notion of seeing the blockchain in terms of state transitions using mathematical notation akin to that used in existing work such as the Ethereum yellow paper. However, standard mathematical notation poses an unnecessary obstacle to clarity in two common situations:\n There isn\u0026rsquo;t a reasonable way of representing data with many named fields (\u0026ldquo;structs\u0026rdquo;). Sets of key-value tuples don\u0026rsquo;t capture the fact that a canonical field ordering exists, while straight tuples of values force the keys of a struct $s$ to be the extremely inconvenient $s_1$,$s_2$,etc When we need to introduce many variables, the mathematical convention of using single-letter variables hinders clarity just like code that uses single-letter variables. It\u0026rsquo;s often difficult to keep track of a bunch of uppercase, lowercase, and Greek letters that aren\u0026rsquo;t shorthand for obvious words.  Thus, for the remainder of the paper, we will use a \u0026ldquo;hybrid\u0026rdquo; approach:\n Actions will be written in terms of both mathematical functions and pseudocode Datatypes will be defined using the Rust programming language Names are often \u0026ldquo;codelike\u0026rdquo;, i.e. we might name a transaction $\\mathsf{foobar}$ rather than $T_1$.  We hope this combines the clarity of \u0026ldquo;pseudocode notation\u0026rdquo; and the succinctness of mathematical notation.\nState transitions a glance Let\u0026rsquo;s first take a look at the basic flow of Themelio\u0026rsquo;s state transitions. As the following picture illustrates, this is based on two basic datatypes State and SealedState. Both of these datatypes will be described in further detail later.\nState: transaction-level state State is the datatype representing the transaction-level state in Themelio. Transactions can be applied to States using the state-transition function $\\Upsilon$.\nHowever, transaction-level state transitions cannot create new blocks. With only $\\Upsilon$, each State is \u0026ldquo;stuck\u0026rdquo; at a particular height; there is no transaction that can force the blockchain to grow to a new height.\nThus, $\\Upsilon$ can also be considered the intraheight state transition function, and transactions intraheight state transitions. State can also be thought of as representing the incomplete next block that is being built.\nWhen a block is ready, the State is sealed with the block sealing function $\\Omega$ to produce a SealedState.\nSealedState: block-level state SealedState represents the block-level state in Themelio, and corresponds to a certain block height. It is \u0026ldquo;sealed\u0026rdquo; in the sense that no more transactions at that block height can be accepted. SealedStates are the subject of blockchain consensus, and the canonical blockchain state is defined only through a series of SealedStates.\nThe only operation possible on a SealedState is to advance it, converting it to a State that accepts transactions for the next block.\nCommon functions \u0026amp; datatypes We now discuss some supporting functions and datatypes that will be recurring in our description of Themelio\u0026rsquo;s logic:\nSerialization Themelio uses bincode serialization. Bincode has the following properties that make it very suitable for serializing Themelio data:\n Very fast Well-integrated with Rust\u0026rsquo;s serde serialization ecosystem Each serializable object has one canonical serialization. This makes concepts like \u0026ldquo;the hash of a transaction\u0026rdquo; trivially well-defined.  In particular, we use bincode with:\n Little-endian, varint encoding of integers Trailing bytes banned  (see the source code)\nWe omit serialization and deserialization from our algorithm descriptions. For example, the hash of the bincode serialization of $v$ is simply denoted $H(v)$.\nCryptography  HashVal represents a 256-bit hash, generally an output of the BLAKE3-256 hash function. The BLAKE3-256 hash function of a value $v$ is denoted $H(v)$, while the BLAKE3-256 keyed hash with key $k$ is denoted $H_k(v)$. Ed25519PK represents an ed25519 public key. Ed25519SK represents an ed25519 secret key.  Sparse Merkle trees Key-value mappings in the Themelio state are generally represented as sparse Merkle trees. Sparse Merkle trees use some neat tricks to efficiently encode a Merkle tree with $2^{256}$ elements, which can be used as a mapping from 256-bit keys to values. An important property is that given any SMT of $N$ elements, there is a 256-bit root hash that uniquely identifies the dictionary, and proofs of inclusion and exclusion of size $\\Theta(\\log N)$ can be produced. Anybody with the root hash can use these proofs to verify that a certain key-value binding either exists or doesn\u0026rsquo;t exist in the SMT. The specifics can be seen in the autosmt crate of themelio-core.\nOn this page, a typed SMT between datatypes K and V, SmtMapping\u0026lt;K, V\u0026gt;, is often used. This denotes a SMT mapping between $H(k), k \\in K$ and values of type $V$. Given a value $M$ of type SmtMapping\u0026lt;K,V\u0026gt;, we also write\n $v=M[k]$ to denote the value mapped to by $k$ $\\pi=\\mathsf{Pie}(M, k, v)$ to denote a proof of in\/exclusion that $k$ is in $M$  SMTs allow us to commit to large datasets succinctly, and is key to thin-client scalability in Themelio.\n World state Overview of elements The world state, State, is the basic structure that encapsulates all the information needed to validate a single transaction. There is a one-to-one mapping between world states and entire blockchain histories, and other concepts such as the block-level SealedState are derived from State.\nState is defined as follows:\npub enum NetID { Testnet = 0x01, Mainnet = 0xff, } pub struct State { \/\/ Identifies the network.  pub network: NetID \/\/ Core state  pub height: u64, pub history: SmtMapping\u0026lt;u64, Header\u0026gt;, pub coins: SmtMapping\u0026lt;txn::CoinID, txn::CoinDataHeight\u0026gt;, pub transactions: SmtMapping\u0026lt;HashVal, txn::Transaction\u0026gt;, \/\/ Fee economy state  pub fee_pool: u128, pub fee_multiplier: u128, pub tips: u128, \/\/ Melmint\/Melswap state  pub dosc_speed: u128, pub pools: PoolMapping, \/\/ Consensus state  pub stakes: SmtMapping\u0026lt;HashVal, StakeDoc\u0026gt;, } We now take a look at its individual elements.\nCore state Network ID The state always carries a network ID, which identifies whether the state belongs to the canonical \u0026ldquo;mainnet\u0026rdquo; (NetID::Mainnet) or a temporary \u0026ldquo;testnet\u0026rdquo;. The genesis state has a hardcoded network ID, and this ID can never be changed by any state transition. This makes different network separate at the level of the state-transition function.\nHeight and history The first two elements position the state within the series of blocks that form the blockchain:\n State::height is number of blocks since the beginning of the blockchain. Thus, we talk about the block with height 0, 1, 2, \u0026hellip; State::history is a SMT that maps each previous height with a Header. Header is a fixed-size type that summarizes and commits to State:  pub struct Header { pub network: NetID, pub previous: HashVal, pub height: u64, pub history_hash: HashVal, pub coins_hash: HashVal, pub transactions_hash: HashVal, pub fee_pool: u128, pub fee_multiplier: u128, pub dosc_speed: u128, pub pools_hash: HashVal, pub stake_doc_hash: HashVal, } Coin mapping The most important component of Themelio\u0026rsquo;s world state is the coin mapping, State::coins. Each key in this SMT is a CoinID, a structure that uniquely identifies a coin by the hash of the transaction that produced it, as well as an index into its outputs:\npub struct CoinID { pub txhash: HashVal, pub index: u8, } For example, CoinID{txhash: foobar, index: 1} identifies the second output of the past transaction with hash foobar.\nEach CoinID maps to a CoinDataHeight:\npub struct CoinData { pub covhash: HashVal, pub value: u64, pub denom: Vec\u0026lt;u8\u0026gt;, } pub struct CoinDataHeight { pub coin_data: CoinData, pub height: u64, } This essentially encapsulates the transaction\u0026rsquo;s \u0026ldquo;associated data\u0026rdquo;. More specifically:\n covhash specifies the hash of the MelVM covenant that constrains the transactions allowed to unlock this coin value specifies the value of the transaction denom identifies the denomination of the coin. Generally, this is the hash of the transaction that first created the new denomination. There are three special cases for builtin assets:  m identifies micromels s identifies microsyms d identifies microdosc    The basic action of a transaction is to remove coins from State::coins and put newly created coins in.\nTransaction mapping The transaction mapping contains all the transactions within the last block, mapping the transaction hash $H(T)$ to the transaction $T$. Transactions themselves are structures which we\u0026rsquo;ll describe in a later section.\nNote that the world state does not anywhere contain the ordering of the transactions. This is because transactions within a block are unordered: unlike almost all existing blockchains, there is no defined order of transactions beyond which block they belong to. As we will see in, this allows for easy parallelization of transaction processing.\nFee economy state The fee economy state consists of:\n State::fee_pool, the fee pool of accumulated base fees that funds staker rewards. This can be thought of as belonging to all stakers. State::fee_multiplier, the fee multiplier that scales the amount of fees transactions are required to have. State::tips, the tips that are fees local to this block, paid to the block proposer when this State is sealed.  These variables interact with Themelio\u0026rsquo;s fee system, which we will describe in the transaction-level and block-level state transition functions.\nMelmint\/Melswap state The Melmint\/Melswap state is used to control the Melmint mechanism that stabilizes the value of each mel. This consists of:\n State::dosc_speed, the DOSC speed that measures how much work the fastest processor can do in 24 hours. State::pools, a mapping from token denominations to values of type PoolState  The precise ways these variables are used are discussed in the Melmint\/Melswap specification.\nConsensus state The consensus state is used to keep track of the stakers that participate in Themelio\u0026rsquo;s consensus. For every transaction $T$ that stakes a certain number of syms, it maps $H(T)$ to a value of type StakeDoc:\npub struct StakeDoc { pub pubkey: Ed25519PK, pub e_start: u64, pub e_post_end: u64, pub syms_staked: u64, } The fields of StakeDoc have the following significance:\n pubkey denotes the ed25519 public key of the staker, used in consensus e_start denotes the first epoch (period of 100,000 blocks) that the staker has voting power. This must be greater than the epoch in which $T$ was confirmed. e_post_end denotes the first epoch after the last epoch in which the staker has voting power. For example, if an staker has voting power for epochs 1, 2, and 3, then e_post_end is 4. syms_staked denotes the number of syms staked by this staker.  The details of how these values are used will be discussed in the state transition functions.\n Blocks, transactions, and state transitions We now look at the actual structure of blocks and transactions in Themelio, which will also let us discuss the core state-transition functions of $\\Upsilon$ (apply), $\\Omega$ (seal), and $\\Delta$ (advance).\nTransactions We start by taking a look at the structure of transactions, as well as the different kinds of transactions:\npub struct Transaction { pub kind: TxKind, pub inputs: Vec\u0026lt;CoinID\u0026gt;, pub outputs: Vec\u0026lt;CoinData\u0026gt;, pub fee: u64, pub covenants: Vec\u0026lt;melvm::Covenant\u0026gt;, pub data: Vec\u0026lt;u8\u0026gt;, pub sigs: Vec\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt;, } pub enum TxKind { Normal = 0x00, Stake = 0x10, DoscMint = 0x50, Swap = 0x51, LiqDeposit = 0x52, LiqWithdraw = 0x53, Faucet = 0xff, } Transaction\u0026rsquo;s fields have the following meanings:\n kind: a byte denoting what kind of transaction the transaction is. Most transactions are of type Normal. inputs: a vector of coins, identified by CoinID, that the transaction is spending outputs: a vector of coins, described by their CoinData, that the transaction is creating fee: total fees paid, in µmel covenants: a vector of MelVM covenants, used to \u0026ldquo;fill in\u0026rdquo; the covenant hashes in the input coins\u0027 associated data data: arbitrary associated data sigs: a vector of \u0026ldquo;signatures\u0026rdquo;, or malleable associated data. This is used when computing hashes: given a transaction $T$, the hash $H(T)$ is actually $H(T\u0027)$, where $T\u0027$ has an empty sigs field.  Applying a transaction to the world state Now that we know the elements of each transaction $T$, we can describe the transaction-level state transition function $\\Upsilon$. Applying a transaction to the state involves three steps: $\\Upsilon^I$, where the inputs of the transaction are spent, $\\Upsilon^O$, where the outputs of the transaction are added to the state, and $\\Upsilon^S$, where effects and constraints of non-ordinary kinds are applied.\nThe algorithm of applying and verifying a transaction against a world state is described as follows. We will discuss ``special\u0027\u0027 transactions, the fee economy, and MelScript constraints separately.\nSpending a transaction\u0026rsquo;s inputs We check the MelVM covenants of each coin, and make sure the input and output coins are balanced for each denomination. The MelVM covenants are not stored in the coin \u0026mdash; only their hashes are \u0026mdash; so the transaction must supply the contents of the covenants in the covenants field.\n $\\Upsilon^I(\\sigma, T)$:  for each $\\mathtt{coinid}$ in $T.\\mathtt{inputs}$  if $\\mathtt{coinid.txhash}$ is a key in $\\sigma.\\mathtt{stakes}$ or $\\sigma.\\mathtt{auction\\_bids}$, then the coin is frozen and we abort. remove $\\mathtt{coinid} \\Rightarrow \\mathtt{coindataheight}$ from $\\sigma.\\mathtt{coins}$ find $\\mathtt{cov}$ s.t. $\\exists h \\in T.\\mathtt{covenants}$ where $H(\\mathtt{cov}) = h$ check that $T$ satisfies the MelVM covenant $\\mathtt{cov}$   check that $T$\u0026rsquo;s inputs and outputs are balanced: for every denomination that is not the empty string, total number created (including fees) must equal total number spent. One exception: for $\\mathtt{DoscMint}$ transactions, DOSC-denominated \u0026ldquo;balancing\u0026rdquo; is ignored and deferred to $\\Upsilon^*$. apply fees:  check that $T.\\mathtt{fees} \u0026gt; \\mathsf{Weight}(T)\\times\\sigma.\\mathtt{fee\\_multiplier}$ increment $\\sigma.\\mathtt{tips}$ by $T.\\mathtt{fees} - \\mathsf{Weight}(T)\\times\\sigma.\\mathtt{fee\\_multiplier}$ increment $\\sigma.\\mathtt{fee\\_pool}$ by $\\mathsf{Weight}(T)\\times\\sigma.\\mathtt{fee\\_multiplier}$   return the changed $\\sigma$    Applying a transaction\u0026rsquo;s outputs No checking is done in this phase; we simply add the outputs into the state. For coins with the denomination of an empty string, we replace the denomination with the hash of the transaction; this is how Themelio implements custom tokens.\n $\\Upsilon^O(\\sigma, T)$:  for each $i$th $\\mathtt{coindata}$ in $T.\\mathtt{outputs}$  if $\\mathtt{coindata.denom}$ has length zero,  set $\\mathtt{coindata.denom}$ to $H(T)$   insert $\\mathtt{CoinID\\{txhash: H(T), index: i \\}}$ into $\\sigma.\\mathtt{coins}$   return the changed $\\sigma$    Applying \u0026ldquo;special\u0026rdquo; actions Here we handle all the special actions of non-Normal transactions.\n $\\Upsilon^S(\\sigma,T)$:  if $T.\\mathtt{kind}=\\mathtt{DoscMint}$  let $\\mathtt{cdh}=\\sigma.\\mathtt{coins}[T.\\mathtt{inputs}[0]]$ if $\\sigma.\\mathtt{height} - \\mathtt{cdh.height} \u0026lt; 100$ then abort (can\u0026rsquo;t measure such small timeframes accurately) let $\\chi=H_{\\sigma.\\mathtt{history}[\\mathtt{cdh.height}]}(T.\\mathtt{inputs}[0])$ let $(d, \\pi) = T.\\mathtt{data}$ verify MelPoW proof with seed $\\chi$, difficulty exponent $d$, and proof $\\pi$ (TODO) measure speed of minter $\\mathtt{my\\_speed}$ as $2^d\/(\\sigma.\\mathtt{height} - \\mathtt{cdh.height})$ let $\\delta=\\frac{2^d \\times \\mathtt{my\\_speed}}{\\sigma.\\mathtt{dosc\\_speed}}$ ensure that the total output DOSC do not exceed $\\delta$   else if $T.\\mathtt{kind}=\\mathtt{Stake}$  check that $T.\\mathtt{data}$ deserializes to a valid StakeDoc check that the first input of $T$ is $s$ Sym, where $s$ is the value in StakeDocs check that e_post_end is greater than e_start in the StakeDoc, and that e_start is in the future insert $H(T) \\Rightarrow T.\\mathtt{data}$ into $\\sigma.\\mathtt{stakes}$.      Batch-applying transactions We note two peculiar properties of Themelio transactions. First, for normal transactions where $\\Upsilon^S$ is a no-op, it\u0026rsquo;s clear that for any set of transactions $T_1,T_n$, we obtain the same final state no matter in what order we apply the transactions to a starting state. There may be orders in which the application fails halfway through (for example, attempting to apply $T_j$ before $T_i$ while $T_j$ spends an output of $T_j$), but for all valid orders, the result will be the same. Intuitively, this is because all transactions do is remove and add coins into the state.\nFurthermore, the \u0026ldquo;special action\u0026rdquo; function $\\Upsilon^S$ is carefully designed so that this same property, which we call order-independence, holds for all transactions. An interesting implication of order-independence is that there is no such thing as the order of transactions within a block \u0026mdash; blocks contain sets, not lists, of transactions. This is why for a State $\\sigma$, $\\sigma.\\mathtt{transactions}$ is an unordered mapping, not a list, of transactions.\nSecondly, for each transaction the order in which $\\Upsilon_I$ and $\\Upsilon_O$ is applied does not actually matter. That is, the transaction can actually add its outputs to the state before spending its inputs, and this will always behave exactly the same way as the \u0026ldquo;natural\u0026rdquo; order. This is because a transaction can never either directly or indirectly refer back to its own outputs in its inputs, due to preimage resistance of the hash function.\nThese two properties allow us to batch-apply an unordered set of transactions that may depend on each other \u0026mdash; given a set of transactions $T^{\u002b}={T_i}$ and a starting state $\\sigma$, produce $\\sigma\u0027 = \\Upsilon^\u002b(\\sigma, T^\u002b) = \\Upsilon(\\dots\\Upsilon(\\Upsilon(\\sigma, T_1), T_2), \\dots T_n)$ where $(T_1,\\dots,T_n)$ is some topological sorting of the transactions \u0026mdash; without actually computing a topological sort at all. This is done by first apply all the outputs, and then applying the inputs and special functions:\n $\\Upsilon^\u002b(\\sigma, T^\u002b)$:  for $T_i \\in T^\u002b$  set $\\sigma= \\Upsilon^O(T_i)$   for $T_i \\in T^\u002b$  set $\\sigma= \\Upsilon^I(T_i)$   for $T_i \\in T^\u002b | T_i.\\mathtt{kind} \\neq \\mathtt{Normal}$  set $\\sigma= \\Upsilon^S(T_i)$   return $\\sigma$    Blocks We now talk about blocks, and $\\Omega$, the \u0026ldquo;state-sealing\u0026rdquo; function that builds blocks.\nState sealing SealedState, representing a canonical state at a certain block height, simply wraps a State and an optional ProposerAction:\npub struct SealedState { pub state: State, pub action: Option\u0026lt;ProposerAction\u0026gt; } pub struct ProposerAction { pub fee_multiplier_delta: i8, pub reward_covhash: HashVal, } SealedState is produced by the state-sealing function $\\Omega(\\sigma, P)$. The \u0026ldquo;proposer action\u0026rdquo; $P$ is an optional non-transaction action that the block proposer uses to pay himself the fees incurred in the block, as well as up\/downvoting the fee level. More specifically,\n fee_multiplier_delta represents how much to change $\\sigma.\\mathtt{fee\\_multiplier}$, where -128 represents the biggest possible decrease and 127 representins the biggest possible increase. The maximum amount the fee multiplier can change is $1\/128$ of the fee multiplier. reward_dest is the covenant hash that the fees of the block will be sent. This is generally an address that the block proposer controls. Every block height, the proposer withdraws $2^{-16}$ times the fee pool, as well as all the tips. This is implemented by adding a coin \u0026ldquo;out of nowhere\u0026rdquo; into $\\sigma.\\mathtt{coins}$.  The state-sealing function is thus:\n $\\Sigma=\\Omega(\\sigma, P)$:  apply all Melmint\/Melswap-related sealing functionality, described in its specification let $\\mathtt{max\\_movement}=\\sigma.\\mathtt{fee\\_multiplier}\/128$ let $\\mathtt{scaled\\_movement}=\\mathtt{max\\_movement}\\times P.\\mathtt{fee\\_multiplier\\_delta}\/128$ increment\/decrement $\\sigma.\\mathtt{fee\\_multiplier}$ by $\\mathtt{scaled\\_movement}$ let $\\mathtt{base\\_fees}=\\sigma.\\mathtt{fee\\_pool}\/2^{16}$ let $\\mathtt{total\\_reward}=\\mathtt{base\\_fees}\u002b\\sigma.\\mathtt{tips}$ set $\\sigma.\\mathtt{tips}=0$ let $\\mathtt{pseudocoin\\_id}=\\mathsf{RewardPseudo}(\\sigma.\\mathtt{height})$ let $\\mathtt{pseudocoin\\_data}$ be a CoinDataHeight with a CoinData that transfers total_reward µmel to $P.\\mathtt{reward\\_covhash}$ insert $\\mathtt{pseudocoin\\_id} \\Rightarrow \\mathtt{pseudocoin\\_data}$ into $\\sigma.\\mathtt{coins}$ return SealedState with $\\sigma$ and $P$    State advancement Given a confirmed SealedState at height $n$, how does the blockchain proceed? It needs to somehow \u0026ldquo;advance\u0026rdquo; the SealedState to a State at height $n\u002b1$. This is the purpose of the state-advance function, $\\sigma^0_{n\u002b1}=\\Delta(\\Sigma_n)$:\n Insert the current block header into State::history Advance height by 1 Remove all stale entries in State::stakes Update State::dosc_speed  \u0026ldquo;Block\u0026rdquo; representation We can now present Block: all the information required to get from a SealedState at height $n$ to a SealedState at height $n\u002b1$:\npub struct Block { pub header: Header, pub transactions: im::HashSet\u0026lt;Transaction\u0026gt;, pub proposer_action: Option\u0026lt;ProposerAction\u0026gt;, } Note that this implies Block is entirely a derived concept for ease of serialization. In this sense, Themelio can be thought of as not really a \u0026ldquo;blockchain\u0026rdquo; at all!\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/yellow\/"
              },
              
              {
                value: "Whitepapers",
                label: "<p></p><p></p>",
                url: "https:\/\/docs.themelio.org\/whitepapers\/"
              },
              
              {
                value: "Themelio: a stable blockchain for an unstable world",
                label: "<p>Abstract Themelio is a decentralized, public blockchain designed to support a new blockchain paradigm, where the blockchain is used as a low-level, stable, and simple root of trust rather than an application or full-featured application platform. We present evidence that this new paradigm is crucial for blockchains to fully realize their key feature of endogenous trust, or trust generated not through preexisting trust in protocol participants but through internal cryptoeconomic mechanisms.\nWe then describe the Themelio blockchain in a high-level fashion, focusing on three areas key to its overall theme of extreme stability and strong endogenoust rust: a traditional yet enhanced UTXO model with features that allow powerful programmability and composability, a novel proof-of-stake system with unusually strong cryptoeconomic guarantees, and Themelio\u0026rsquo;s unique cryptocurrency the mel, which achieves stablecoin-like low volatility without any compromises in decentralization and security.\nFinally, we explore possible applications of Themelio, ranging from simple payment systems to autonomous decentralized applciations.\nRead full PDF\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/whitepapers\/themelio\/"
              },
              
              {
                value: "My first alphanet transaction",
                label: "<p>This document will guide you through setting up a Themelio alphanet client and sending your first transaction. Before you follow the steps listed here, you probably want to read the introduction to Themelio to understand some basic concepts.\nAssumptions All the instructions here assume that\n You\u0026rsquo;re running a Unix (Linux or macOS) system. The alphanet client should work on Windows, but it isn\u0026rsquo;t well-tested. You have a working Internet connection You have git installed You have a stable Rust compiler, including the cargo command  Install themelio-core Install themelio-core with cargo directly from GitHub:\n$ cargo install --git https:\/\/github.com\/themeliolabs\/themelio-core.git themelio-core cargo downloads and compiles the entire Themelio codebase and all its dependencies. This will take a while.\nCreate Alice\u0026rsquo;s and Bob\u0026rsquo;s wallets Before we send any transactions, we first create two wallets between which we can send money.\nStart the client themelio-core is a monolithic program with a large number of subcommands that each implement some Themelio-related service. Right now, all you want is to run a thin-client wallet, so run\n$ themelio-core anet-client [anet client v0.1.0]% You should see a command prompt show up. This prompt will be the main interface you use to interact with Themelio\u0026rsquo;s alphanet as a thin client.\nCreate two wallets To create a wallet, use the wallet-new command:\n[anet client v0.1.0]% wallet-new alice \u0026gt;\u0026gt; Created wallet \u0026#34;alice\u0026#34; \u0026gt;\u0026gt; Address: \u0026lt;ALICE_ADDRESS\u0026gt; \u0026gt;\u0026gt; Secret: \u0026lt;ALICE_SECRET\u0026gt; This generates and stores to disk a new wallet called \u0026ldquo;alice\u0026rdquo;, printing out the address and the secret. Note both of these values.\n The wallet secret will not be saved to disk! You should back up the secret somewhere safe if you need to recover the contents of the wallet.\n Repeat the process for Bob, and you\u0026rsquo;re done for this step.\nAdd money to Alice\u0026rsquo;s wallet Open Alice\u0026rsquo;s wallet We first need to open Alice\u0026rsquo;s wallet using the secret:\n[anet client v0.1.0]% wallet-unlock alice \u0026lt;ALICE_SECRET\u0026gt; \u0026gt;\u0026gt; Wallet unlocked successfully! [anet client v0.1.0](alice)% This gives us a command prompt within the context of the alice wallet.\nUse the alphanet faucet Themelio\u0026rsquo;s alphanet has a faucet facility that allows anybody to print mels out of thin air. The faucet allows easy testing on the alphanet and would of course be removed in the mainnet.\nLet\u0026rsquo;s print 1000 mels:\n[anet client v0.1.0](alice)% faucet 1000 TML \u0026gt;\u0026gt; Faucet transaction for 1000 broadcast! \u0026gt;\u0026gt; Waiting for confirmation... \u0026gt;\u0026gt; Confirmed at block 10! \u0026gt;\u0026gt; CID=\u0026lt;FAUCET_CID\u0026gt; This gives us a coin ID, or CID, that we use as a \u0026ldquo;receipt\u0026rdquo; to insert coins into the wallet:\n[anet client v0.1.0](alice)% coin-add \u0026lt;FAUCET_CID\u0026gt; \u0026gt;\u0026gt; Syncing state... \u0026gt;\u0026gt; Coin found! Added 1000.0000 TML to wallet Send money to Bob Send the transaction Now we are ready to send money to Bob. Let\u0026rsquo;s send over 500 TML:\n[anet client v0.1.0](alice)% tx-send \u0026lt;BOB_ADDRESS\u0026gt; 500 TML \u0026gt;\u0026gt; Syncing state... \u0026gt;\u0026gt; Fee required: 0.0123 TML. Accept? [y\/n] y \u0026gt;\u0026gt; Transaction \u0026lt;TXID\u0026gt; broadcast! \u0026gt;\u0026gt; Waiting for confirmation... \u0026gt;\u0026gt; Confirmed at block 10! \u0026gt;\u0026gt; CID=\u0026lt;ALICE_TO_BOB_CID\u0026gt; This gives us another CID that Bob will use to receive the money.\nOpen Bob\u0026rsquo;s wallet We now open Bob\u0026rsquo;s wallet to receive Alice\u0026rsquo;s money:\n[anet client v0.1.0](alice)% exit [anet client v0.1.0]% wallet-open bob \u0026lt;BOB_SECRET\u0026gt; \u0026gt;\u0026gt; Wallet unlocked successfully! [anet client v0.1.0](bob)% Receiving the money We use the CID to receive the money from Alice:\n[anet client v0.1.0](bob)% coin-add \u0026lt;ALICE_TO_BOB_CID\u0026gt; \u0026gt;\u0026gt; Syncing state... \u0026gt;\u0026gt; Coin found! Added 500.0000 TML to wallet Congratulations! You\u0026rsquo;ve successfully sent 500 mels from Alice to Bob. Alice now has 499.987 TML in her wallet, while Bob has 500 TML.\nNext steps In this guide, you used a validating thin client that does not synchronize the entire blockchain state. This has slightly less security and doesn\u0026rsquo;t allow much functionality without a reliable Internet connection, so in some applications you would want to run an auditor node to replicate and fully validate blocks. That\u0026rsquo;s covered in the next guide.\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/try-themelio\/alphanet-client\/"
              },
              
              {
                value: "Running an auditor node",
                label: "<p>Running an auditor node This document will guide you through setting up an auditor, which is the equivalent of a full node in most other blockchains. An auditor replicates every consensus-confirmed block, validating its contents and ensuring network security while providing a local cache of the entire blockchain state.\nAssumptions All the instructions here assume that you have an up-to-date themelio-core binary installed. If not, simply install it with cargo:\n$ cargo install --git https:\/\/github.com\/themeliolabs\/themelio-core.git Running the auditor To run an auditor, just run:\n$ themelio-core anet-node --bootstrap 94.237.109.116:11814 You should see output similar to the following:\nDec 29 20:47:55.627 INFO run_main:run_node: themelio_core: themelio-core v0.1.0 initializing... Dec 29 20:47:55.627 INFO run_main:run_node: themelio_core: bootstrapping with [94.237.109.116:11814] Dec 29 20:47:55.627 INFO run_main:run_node:open_testnet{path=\u0026#34;\/tmp\/testnet\u0026#34;}: themelio_core::storage: creating a testnet genesis state from scratch Dec 29 20:47:56.526 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 0 with 0 transactions Dec 29 20:47:56.526 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block special case when height is zero Dec 29 20:47:56.527 DEBUG blksync_loop:apply_block: themelio_core::storage: block 0, txcount=0, hash=#\u0026lt;f8dbd36a0f\u0026gt; APPLIED Dec 29 20:47:57.377 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 1 with 0 transactions Dec 29 20:47:57.377 DEBUG blksync_loop:apply_block: themelio_core::storage: block 1, txcount=0, hash=#\u0026lt;c2182ca753\u0026gt; APPLIED Dec 29 20:47:58.379 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 2 with 0 transactions Dec 29 20:47:58.380 DEBUG blksync_loop:apply_block: themelio_core::storage: block 2, txcount=0, hash=#\u0026lt;d741c12dcc\u0026gt; APPLIED Dec 29 20:47:59.336 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 3 with 0 transactions Dec 29 20:47:59.337 DEBUG blksync_loop:apply_block: themelio_core::storage: block 3, txcount=0, hash=#\u0026lt;f6a0829cd2\u0026gt; APPLIED Dec 29 20:48:00.285 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 4 with 0 transactions Your auditor is now running and replicating blocks within the auditor peer-to-peer gossip network.\nNote: right now the auditor implementation is not very useful, since not much happens in the network that\u0026rsquo;s interesting to replicate!\nConnecting a client to the auditor One of the most common uses of a local auditor node is to connect to a thin client in order to free the thin client from depending on a remote server for availability and latency. Try following the alphanet client tutorial, except by running\nthemelio-core anet-client --bootstrap 127.0.0.1:11814 </p><p></p>",
                url: "https:\/\/docs.themelio.org\/try-themelio\/auditor-node\/"
              },
              
              {
                value: "Synkletos: Themelio\u0027s collusion-resistant consensus mechanism",
                label: "<p>Abstract In this whitepaper, we discuss Synkletos, the core cryptoeconomic mechanism that powers Themelio\u0026rsquo;s proof-of-stake consensus. Consensus algorithms used to secure public blockchains differ significantly in their design constraints from those driving traditional fault-tolerant distributed systems. This is because blockchains must rigorously model trust within a game-theoretical model, rather than simply making assumptions about fault tolerance. To truly achieve incentive-compatible security, we cannot rely on the typical approach of considering ideal honest behavior and then positing an adversary with certain powers. Unfortunately, game-theoretical analysis of multi-party coordination problems, of which blockchain consensus is an instance, tends to be pernicuously difficult, leading to most consensus algorithms in use lacking formal analysis.\nSynkletos is a blockchain consensus algorithm designed through a novel approach that drastically simplifies incentive analysis. Instead of modeling the ideal blockchain as decentralized parties participating in a coordination game to produce a certain optimal behavior, we start by proposing an ideal monopoly blockchain, where blockchain rules are such that even a selfish monopoly will behave in a \u0026ldquo;faulty\u0026rdquo; way. We then design an simple incentive structure and consensus algorithm based on a variation of proof of stake that incentivizes any number of uncoordinated or coordinated parties to simulate such a monopoly as a whole. We argue that such a mechanism, though it is slightly less economically efficient compared to systems such as Nakamoto consensus that rely on noncoordination assumptions, is much easier to analyze and far more robust to game-theoretical attacks. Finally, we validate this by constructing Synkletos for Themelio and running an agent-based incentive simulation.\nRead full PDF\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/whitepapers\/synkletos\/"
              },
              
              {
                value: "Try Themelio",
                label: "<p></p><p></p>",
                url: "https:\/\/docs.themelio.org\/try-themelio\/"
              },
              
              {
                value: "Consensus specification (WIP)",
                label: "<p>In this page, we specify Synkletos, Themelio\u0026rsquo;s consensus algorithm. We give a concrete instantiation of the concepts discussed in the Synkletos whitepaper.\n Basic concepts Let\u0026rsquo;s start by introducing some basic concepts that are needed to understand Synkletos.\nThree consensus roles In Themelio, all participants in the blockchain belong to one of three roles:\n Stakers directly participate in consensus. They have stake, denominated in Sym, locked up on-chain, and receive consensus voting power in exchange. Votes from stakers owning at least 2\/3 of the on-chain stake \u0026mdash; a quorum \u0026mdash; is needed to confirm a block. Auditors correspond to \u0026ldquo;full nodes\u0026rdquo; in other blockchain. They do not own stake, but replicate and validate the output of the staker consensus. They not only provide a \u0026ldquo;CDN\u0026rdquo; for the blockchain, but more importantly by using a nuking procedure, they shut the network down if a quorum of stakers produces invalid results. Clients are pure consumers of consensus. They do not replicate the blockchain, but trust consensus proofs provided by the stakers that commit to a particular blockchain state, and as long as the stakers are trustworthy and the auditors are operating correctly, clients cannot be fooled.  In this document, we largely focus on the stakers, since they are the one who directly participate in consensus.\nProof of stake Stakers lock up Sym, a token that is used only for proof-of-stake. On chain, this is represented by coins of denomination DENOM_TSYM, and similar to the mel, 1,000,000 on-chain units (µsym) equals \u0026ldquo;one sym\u0026rdquo;.\nCompared to most other PoS mechanisms, Themelio\u0026rsquo;s PoS has two uncommon features:\n Stakers precommit to how long to lock up their syms. There is no mechanism for early withdrawal. The period of time in which a staker has voting power is not perfectly aligned with the time in which the syms are locked up. Instead, voting power always stays constant within an epoch of 100,000 blocks (~ 34 days).  Both of these features are designed to mitigate the \u0026ldquo;weak subjectivity\u0026rdquo; problem and maximize security and usability for clients. We will discuss the detailed mechanics in a subsequent section.\n Stakes, epochs, and slashing In this section, we discuss the on-chain mechanics of keeping track of stakers\u0027 stakes and their associated consensus votes. This is separate from the actual consensus algorithm, which takes in these stakes as an input and decides on blocks.\nStakes We start by looking at how stakers lock up syms. To stake a sum of sym, a transaction $T$ with kind Stake is sent, the first output of which must be denominated in µsym, and the data field of which is the following structure:\npub struct StakeDoc { \/\/\/ Public key for signing consensus.  pub pubkey: tmelcrypt::Ed25519PK, \/\/\/ First 100,000-block epoch when staker has power.  pub e_start: u64, \/\/\/ Ending epoch. This is the epoch *after* the last epoch in which the syms are effective, and the last epoch in which the syms are locked.  pub e_post_end: u64, \/\/\/ Number of µsyms staked.  pub syms_staked: u128, } The blockchain then checks that:\n e_start is greater than current_block_height\/EPOCH_LENGTH. That is, the starting epoch must be in the future. e_post_end is greater than e_start. syms_staked is exactly equal to the value of the first output of the transaction  If all these conditions hold, then the first output of the transaction is locked until the end of epoch e_post_end. This is accomplished by adding a binding $H(T) \\Rightarrow T.\\mathtt{data}$ into the stakes binding in the state, which prevents the first output of $T$ from ever being spent until the entry is removed.\nHere is an illustration of a stake that is committed into the blockchain in block 345, with e_start=1 and e_post_end=10. Note that the staker gains voting rights starting at the beginning of epoch 1 and loses them right before epoch 10.\nThrough the consensus algorithm (detailed later), a consensus proof is produced for every block, containing signatures corresponding to the owners of at least 2\/3 of the staked syms whose StakeDocs confer voting rights for that block\u0026rsquo;s height.\nEpochs and voting rights A consequence of having voting rights start and end on epoch boundaries is that within a single epoch, the set of voting stakers is static. That means that we only need a copy of the State::stakes mapping from the end of the previous epoch to validate all consensus proofs in the present epoch.\nThus, the first step any client or auditor must take to validate consensus results is to obtain, in a secure manner, this stake mapping. Yet to validate this stake mapping, the voting power distribution of the previous epoch must be sought, which requires obtaining and validating an even earlier stake mapping! This procedure terminates when the client hits a stake mapping that it already knows.\nSlashing and nuking On evidence of misbehavior, stakers can be slashed. This is done by broadcasting a transaction with kind Slash, with data containing:\npub struct SlashEvidence { bad_staker: Ed25519PK, header_a: Header, header_b: Header, sig_a: Vec\u0026lt;u8\u0026gt;, sig_b: Vec\u0026lt;u8\u0026gt; } This slash evidence contains two headers at the same height with signatures from the same staker \u0026mdash; incontrovertible evidence that the staker attempted equivocation.\nTODO: We need other kinds of slashing too. But the sort of slash proofs required is not always clear, and we hope to use the betanet period to get community feedback on what misbehavior should be slashed.\nFurthermore, if invalid blocks are ever confirmed by a quorum, auditors nuke the network by refusing continued operation and rebroadcasting evidence of the invalid blocks to the entire auditor network. This makes breaking safety without quickly shutting down the network extremely difficult even with the cooperation of all consensus participants, making the set of adversaries who would benefit from breaking consensus safety much smaller.\nIncentives Proposer selection Each block in the blockchain isn\u0026rsquo;t just decided by the whole staker quorum \u0026mdash; it also has a proposer whose primary responsibility it is to put together the block. Proposers, strictly speaking, are not part of the blockchain state-transition function, but part of the consensus algorithm, but we discuss them here because they are crucial to the incentive structure of Themelio.\nProposers are allocated pseudorandomly between the stakers, based on their respective weights. This is done at the beginning of each epoch \u0026mdash; by the time the epoch starts, who the proposer of each block is is already set in stone:\n  First the entropy seed $\\Sigma$ is calculated by a bitwise majority of all the header hashes $h_1,\\dots,h_n$ of the previous epoch. That is, the $i$th bit of $\\Sigma$ is: $$\\Sigma[i] = \\begin{cases} 1 \u0026amp; \\text{if } \\sum_i h_i\u0026gt;n\/2 \\ 0 \u0026amp; \\text{otherwise} \\end{cases}$$\n  Then, the proposer of the $n$th block (counting from genesis) is determined by the selection function $\\mathsf{Select}(n)$:\n Lay out all the stakers in lexicographic order of their public keys. Each staker is then assigned a range in the number line, next to the previous one, the size of which is the number of µsym staked, which includes its starting point but not its endpoint:  Compute a subseed through a keyed hash: $\\Sigma_n=H_n(\\Sigma) \\bmod F$, where $F$ is the smallest power of 2 greater than or equal to the total µsym staked and voting. Until returns:  If $\\Sigma_n$ falls into a range that belongs to a staker, that staker is the $n$th proposer Otherwise, set $\\Sigma_n \\gets H(\\Sigma_n)$      The use of an entropy seed calculated by bitwise majority, rather than, say, the block hash of the last block of the previous epoch, resists \u0026ldquo;stake grinding\u0026rdquo; attacks, where a malicious proposer at the end of the last epoch brute-forces blocks to ensure that it\u0026rsquo;s picked disproportionately often in the next epoch. This is based on the \u0026ldquo;majority beacon\u0026rdquo; idea by TODO\nThe selection function essentially gives each proposer slot to stakers with probability proportional to the fraction of staked, voting syms that it owns.\nFees and block rewards Each block, proposers have the option of collecting fees by using the optional argument in $\\Omega$, the block-sealing function (see the yellow paper). These fees have to components: a base fee that is added to a common fee pool, and tips that are given directly to the proposer. The proposer can also withdraw $2^{-16}$ times the fee pool, as well as change the base fee rate up to $1\/128$ in one direction.\nThe upshot is that tips are given directly to the proposer, while base fees, which are charged a rate determined by a sequential, collective vote, are distributed to all proposers, with a slight bias towards proposers in the near future.\n A concrete consensus We now describe Symphonia, the concrete consensus algorithm that, given the set of voting stakers, produces a series of blocks with correct consensus proofs.\nSymphonia exposes a simple public interface: every 30 seconds or so, a new confirmed block, consisting of a block $B_i$ and a consensus proof $\\Pi_i$ is produced. $\\Pi_i$ is simply a set of signatures whose collective vote weight is greater than 2\/3 of all the voting power in the current epoch.\nConfirmed blocks produced by the mechanism are always consecutive: there will be a separate consensus proof for every block height. This means that the \u0026ldquo;rest of the network\u0026rdquo;, regardless of the actual implementation, can pretend like Symphonia is a series of PBFT-style one-shot consensus algorithm instances, each producing a consensus proof.\nInternally, however, Symphonia uses a variation of STREAMLET, a \u0026ldquo;pipelined\u0026rdquo; algorithm that produces and finalizes blocks separately.\nBasic concepts The blockchain is divided into stake epochs, each lasting 100,000 blocks. Within each stake epoch, the set of voting stakers does not chane. Each voting staker has a vote weight, which is an integer that represents the number of syms staked that is valid for the current epoch.\nThere is a designated proposer at each height, pseudorandomly assigned to a staker weighted by its voting weight. The proposer of each height within an epoch is predetermined at the beginning of the epoch according to a pseudorandom function, as described in the \u0026ldquo;proposer selection\u0026rdquo; section ablve. Thus, it makes sense to talk about the proposer of a block at a height outside an epoch, with respect to the voting set of that epoch.\nEach block height is associated with a block time, a predetermined \u0026ldquo;wall clock\u0026rdquo; time that the block is supposed to be proposed.\nCore algorithm Symphonia is essentially identical to Streamlet, with two major differences:\n  Blocks must be consecutive\n  All finalized blocks carry consensus proofs that can be verified by third parties who did not observe the consensus protocol.\n  There are three parts to Symphonia:\n  Propose-Vote: At the block time for block $h$:\n  The proposer proposes $B_h$ extending from the longest[^1] notarized chain it has seen. If there are multiple longest chains, \u0026ldquo;the longest chain\u0026rdquo; is the one with the smallest block header hash. If the longest notarized chain terminates at $B_j$ where $j \u0026lt; h - 1$, the proposer also proposes empty blocks at heights $B_{j\u002b1},\\dots,B_{h-1}$ within the proposal. These empty blocks must have no transactions and no proposer action present.\n  Every staker votes for the first valid proposal they see from the proposer that extends from the longest notarized chain. This is a signature on $H_\\mathsf{vote}(B_h)$.\n  When a block gains votes from stakers owning at least 70% of the stake (a quorum), it becomes notarized. A chain is notarized if all its constituent blocks are notarized.\n    Finalize: If in any notarized chain, there are three consecutive non-empty blocks, then the prefix of the chain up to the second of the three blocks is final.\n  Confirm: All honest stakers will sign $H_\\mathsf{final}(B_h)$ if $B_h$ is finalized, and will talk to other stakers to assemble a _consensus proof_ $\\Pi_h$ consisting of more than 70% signatures on $H_\\mathsf{final}(B_h)$. $(B_h, \\Pi_h)$ is a _confirmed_ block and will be broadcasted onto the auditor network.\n  Handling epoch transitions One special case we need to handle is the transition between stake epochs. At the end of an epoch, we don\u0026rsquo;t know what set of stakers to use for the next epoch until the last block of the epoch is confirmed. Yet according to the algorithm above, we can\u0026rsquo;t confirm the last block of the epoch until the next block is notarized. This breaks liveness at the end of epochs.\nThus, we modify the algorithm slightly. At the end of an epoch, stakers continue running the consensus algorithm, except that all \u0026ldquo;out of bounds\u0026rdquo; blocks must be empty blocks, and out-of-bounds blocks will never be confirmed, only finalized. This lets the last block of the epoch eventually become confirmed.\nAs soon as the epoch-ending block is confirmed, stakers start a Symphonia instance for the next epoch (if they still have voting power) but continue broadcasting the epoch-ending confirmed block to the auditor network on demand.\nTechnical specs The Melnet instance All stakers join the Melnet network identified as testnet-staker, as well as the auditor network (testnet-auditor). Melnet maintains a connected graph of all stakers, allowing reasonably efficient gossip. This is exposed to each staker as a list of neighbors which the staker can directly send messages to.\nThe entire protocol uses the single Melnet verb symphonia that returns Option\u0026lt;ConfirmResp\u0026gt;. To broadcast a message, we mean to send it to up to 16 randomly selected neighbors.\nMessage format All messages are sequenced and signed. More specifically, the format of an on-wire message is as follows:\n\/\/\/ Message sent *to* a node pub struct SignedMessage { pub sender: Ed25519PK, pub signature: Bytes, \/\/ over (sequence, body)  pub sequence: u64, \/\/ monotonically increasing. clock\u002bctr  pub body: Message, } pub enum Message { Proposal(ProposalMsg), Vote(VoteMsg), GetConfirm(GetConfirmMsg) } pub struct ProposalMsg { pub proposal: AbbreviatedBlock, pub last_nonempty: Option\u0026lt;(u64, HashVal)\u0026gt;, } pub struct VoteMsg { pub voting_for: HashVal, } \/\/\/ Message that responds to a GetConfirmMsg pub struct ConfirmResp { signatures: BTreeMap\u0026lt;Ed25519PK, Bytes\u0026gt; } All messages with invalid signatures are immediately discarded without further processing. For valid messages, each node keeps track of the last sequence number from a given sender; only messages with higher sequence numbers are accepted. This prevents the same broadcasted message from looping in the network indefinitely. When messages are rebroadcast, nothing is changed.\nProposing a new block At each block time, the designated proposer sends a ProposalMsg with Proposal containing its proposed block. If the LNC needs to be extended by possibly many empty blocks to reach this height, the last_nonempty field is set to the height and hash of last non-empty ancestor of the proposed block.\nVoting for the proposal On receiving a proposal, a staker will first see if it\u0026rsquo;s signed by the correct proposer for the given height and properly extends the LNC. If not, it will immediately discard the proposal.\nOtherwise, it will wait until it has seen all its constituent transactions and is able to construct a proper (series of) Block(s). It will then validate the block. If it passes validation, a VoteMsg will be broadcast.\nFinalizing and confirming blocks Finalized blocks are confirmed by repeatedly asking a random neighbor for confirm responses with GetConfirmMsg. Each staker will respond with a mapping containing its own confirmation signature, as well as all the ones it has gotten from its neighbors.\nThis will rapidly construct enough signatures to form a quorum, at which point the confirmed block can be broadcast onto the auditor network.\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/consensus-spec\/"
              },
              
              {
                value: "Melmint v2 specification (WIP)",
                label: "<p>In this page, we will fully specify the actual workings of Melmint on the Themelio blockchain. This is in contrast to the whitepaper, which only provides a high-level design.\nWe call the mechanism Melmint v2 because it has some several important differences with the \u0026ldquo;paper\u0026rdquo; Melmint version.\n Introduction \u0026ldquo;Paper Melmint\u0026rdquo; In our original publication, Melmint is divided into two halves:\n A DOSC\/sym auction that establishes a DOSC\/sym exchange rate A mel\/sym exchange guarantee that allows anybody to destroy 1 mel in exchange for $k$ DOSC worth of newly printed syms, or vice versa, minus a small fee.  The following picture illustrates \u0026ldquo;paper Melmint\u0026rdquo;:\nThe central idea is that through auctioning off a steady stream of sym for DOSC, we know how much computation a sym is worth. We can then \u0026ldquo;back\u0026rdquo; mels with $k$ DOSC worth of newly printed sym.\nThis way, the \u0026ldquo;collateral\u0026rdquo; of a mel is simply the value that can be extracted through diluting syms. Comparisons with existing economies seem to indicate that runs on mels are unlikely because the sym will have significantly higher market cap, but nevertheless \u0026ldquo;paper Melmint\u0026rdquo; has a fairly complex system that detects runs and devalues the mel by adjusting $k$ downwards.\nProblems with \u0026ldquo;paper Melmint\u0026rdquo; Unfortunately, paper Melmint has some significant downsides that make it impractical to implement on Themelio:\n It requires many different transaction types: at least DoscMint (minting DOSC), AuctionBid (for bidding in the auction), AuctionBuyout (for \u0026ldquo;buying out\u0026rdquo; others\u0027 bids from the order book), AuctionFill (generated automatically to award the sym to the highest bidder), and Swap (to swap between sym and mel). This is clunky and inelegant, and our abortive attempt at implementing \u0026ldquo;paper Melmint\u0026rdquo; caused a huge fraction of our transaction processing code to be solely devoted to Melmint. Auctions are notoriously tricky to get right. Although the addition of \u0026ldquo;auction buyouts\u0026rdquo; (which also complicates implementation) probably makes it hard to game the \u0026ldquo;oracle\u0026rdquo; derived from the DOSC\/sym auction, participants will still need to do a lot of tricky strategizing. Furthermore, the 20-block auction period makes frontrunning, \u0026ldquo;blockchain clock\u0026rdquo; inaccuracy, etc very problematic. Demurrage is tricky. DOSCs are supposed to have demurrage, or a face value that decays over time. This is tricky to implement in Themelio\u0026rsquo;s strict UTXO model, without lots of special casing for DOSCs.  Thus, Melmint v2, while keeping the core idea of paper Melmint, completely revamps the specifics of how the mel\/DOSC peg is maintained. The auction with a general swapping mechanism, and demurrage is replaced with DOSC inflation.\nAn overview of Melmint v2 Melmint v2 is based on Melswap, a Uniswap v1-inspired \u0026ldquo;token swapping\u0026rdquo; mechanism built into Themelio. All non-mel tokens can be swapped with Mel using Melswap, and a liquidity provider reward mechanism incentivizes participation.\nThere is no more sym auction or inbuilt sym inflation. Instead, we simply use the DOSC\/mel and DOSC\/sym pairs in Melswap to derive the appropriate mel\/sym exchange rate. Every block, more Mel or more Sym will printed and stuffed into the mel\/sym pool in order to target the correct mel\/sym exchange rate.\nWhy not directly target the DOSC\/mel pair? Because we can\u0026rsquo;t let the protocol print DOSCs, lest they no longer become DOSCs. Using the mel\/sym pair as the main \u0026ldquo;lever\u0026rdquo; for monetary policy allows us to extract \u0026ldquo;inflation taxes\u0026rdquo; on sym holders in exactly the same way as paper Melmint does.\nIn lieu of paper Melmint\u0026rsquo;s demurrage, we introduce DOSC inflation. We keep track of an exponentially increasing DOSC inflator $\\kappa$. The difficulty of creating on-chain nominal DOSCs (nomDOSC) is divided by the inflator, so that each nomDOSC represents a smaller and smaller amount of real-world computation. At the same time, the targeted nomDOSC\/mel exchange rate is multiplied by the inflator, so that more and more nomDOSCs are needed to obtain one mel. This has the exact same effect as demurraging a fixed DOSC, without requiring nomDOSC balances to ever change.\n Specification Melswap: a Uniswapesque built-in DEX The foundation of Melmint v2 is Melswap, a decentralized exchange built into Themelio that allows free exchange between any Themelio denom and Mel. Melswap is an extremely simple Uniswap-like \u0026ldquo;constant product\u0026rdquo; automated market maker, and it is based on three concepts: pools, swapping, and liquidity tokens.\nPools We keep a pool that stores liquidity for a particular token and Mel. The transaction level State has a member State::pools of type SmtMapping\u0026lt;Vec\u0026lt;u8\u0026gt;, PoolState\u0026gt;, mapping each denomination to a PoolState structure:\npub struct PoolState { pub mels: u128, \/\/ unit is µmel  pub tokens: u128, pub price_accum: u128, pub liqs: u128, } WLOG, we call the token of a particular pool the \u0026ldquo;token\u0026rdquo;, which is exchanged for µmel\nSwapping Swapping a custom token with Mel, or vice versa, involves sending a sum of money into a particular pool, while withdrawing the other token.\nTo swap a custom token with Mel, we use a transaction with kind Swap. The data field refers to a key in State::pools.\nNothing \u0026ldquo;special\u0026rdquo; happens when the transaction is applied to the state, and it is processed exactly like a transaction of type Normal.\nThis is because to safeguard order-independence of all transactions, the actual execution of all swaps within a block is done on block sealing \u0026mdash; in a sense, swaps settle at the next block height rather than immediately. When a block is sealed, we settle swaps by following this procedure:\n Find all transactions in this block of kind Swap, whose first output has not been spent, whose data field points to an existing pool, and whose first output\u0026rsquo;s denomination is either the pool token or Mel. These are the swap requests. For each pool mentioned in some swap request:  Add the first output of all swap requests for that pool, whether token or Mel, into the pool. Let $\\Delta_m$ be the µmels added, $\\Delta_\\alpha$ be the tokens added, $m$ be the original number of mels, and $\\alpha$ be the original number of tokens. We compute the exchange rate of the token as simply the ratio $X=(\\Delta_\\alpha\u002b\\alpha)\/(\\Delta_m \u002bm)$. We compute exactly how many µmels and tokens to remove from the pool: $W_\\alpha = \\lfloor0.995X\\Delta_m\\rfloor,W_m=\\lfloor0.995X\\Delta_\\alpha\\rfloor$ We change the number of µmels in the pool to $m\u002b\\Delta_m-W_m$, and the number of tokens to $\\alpha\u002b\\Delta_\\alpha-W_\\alpha$. We settle each swap request by transmuting the CoinData binding of their first output in coins, with value $v$:  If the coin is is µmel-denominated, change denom to that of the token, and change value to $$\\frac{vW_\\alpha}{\\Delta_m}$$ If the coin is token-denominated, change denom to µmel, and change value to $$\\frac{vW_m}{\\Delta_\\alpha}$$.   We add $\\lfloor 10^6\\times P \\rfloor$ to price_accum, wrapping around on overflow.    Liquidity tokens To reward people for depositing liquidity into a Melswap pool, we use a Uniswap-like liquidity token system. There are two kinds of transactions, LiqDeposit and LiqWithdrawal.\nSimilar to Swap transactions, they are processed in the \u0026ldquo;pipeline\u0026rdquo; just like Normal transactions, and their effects apply on block sealing using coin transmutation. In particular, when sealing a block, after processing swaps:\n  Process deposits:\n  Find all LiqDeposit transactions in the block, whose first output\u0026rsquo;s denomination is Mel, and whose second output\u0026rsquo;s denomination is the pool token, neither of which have been spent.\n  For each pool, existing or nonexisting, mentioned in some LiqDeposit:\n If the pool doesn\u0026rsquo;t exist:  Create a pool, with $M$ mels and $A$ tokens, where $M$ and $A$ are the total mels and tokens in the first and second outputs of the LiqDeposits for this pool. For each of the LiqDeposits for this pool:  Given that the transaction deposits $m$ mels, transmute the first output to $m$ liquidity tokens. Liquidity tokens have denom $H_\\mathsf{``liq\u0027\u0027}(c)$, where $c$ is the pool token\u0026rsquo;s denom. Delete the second output from the state.   Set liqs of the pool to the total number of liquidity tokens created.   If the pool does exist:  Add all the mels and tokens into the pool. For each of the LiqDeposits for this pool:  Given $m,\\alpha,\\ell,\\Delta_m,\\Delta_\\alpha$, the number of liquidity tokens minted is $$\\Delta_\\ell = \\ell\\left\\lfloor \\sqrt{\\frac{\\Delta_m\\Delta_\\alpha}{m\\alpha}} \\right\\rfloor$$ Update liqs and transmute accordingly.          Process withdrawals\n Find all LiqWithdrawal transactions in the block, whose first output\u0026rsquo;s denomination is the liquidity token of the \u0026ldquo;correct\u0026rdquo; pool, which hasn\u0026rsquo;t been spent. Using exact arithmetic, compute the correct number of mels and tokens to withdraw for every liquidity token. For every LiqWithdrawal transaction, transmute its first output to the floor of the correct number of mels, and synthesize a second output to the floor of the correct number of tokens. Decrement liqs properly. This should never overflow because liqs can\u0026rsquo;t proliferate elsewhere.    The Melmint mechanism Melmint is now a simple \u0026ldquo;central bank\u0026rdquo; mechanism that supplies liquidity to Melswap to loosely target a given DOSC\/mel exchange rate. This is implemented as the following procedure on block seal, after Melswap is processed:\n Calculate the implied sym\/nomDOSC exchange rate $R_{SD}=X_S\/X_D$ through the nomDOSC\/mel exchange rate $X_D$ and sym\/mel exchange rate $X_S$. \u0026ldquo;Nudge\u0026rdquo; the sym\/mel pool, containing $s$ syms and $m$ mels, with towards 1 mel = $\\kappa$ nomDOSC worth of sym, where $\\kappa$ is the DOCS inflator:  Compute the target ratio: $\\hat{R}_{SM} = \\kappa \\times R_{SD}$ We first nudge the number of syms: $s\u0027 = \\lfloor0.9999s \\rfloor \u002b \\lfloor 0.0001(m \\cdot \\hat{R}_{SM}) \\rfloor$ Now the \u0026ldquo;product\u0026rdquo; is out of whack, so we restore the product. Compute the \u0026ldquo;stretch factor\u0026rdquo; $\\gamma=s\u0027\/s$ and set  $s \\gets \\lfloor s\u0027\/\\lfloor\\sqrt{\\gamma}\\rfloor \\rfloor$ $m \\gets \\lfloor m\\cdot \\lfloor\\sqrt{\\gamma}\\rfloor \\rfloor$   This sets the price 1\/10000th closer to the \u0026ldquo;correct\u0026rdquo; exchange rate. Thus, the peg will restore \u0026ldquo;half way\u0026rdquo; in approximately 2 days if market conditions are neutral.    Why are we so conservative with nudging the target rate? This is largely to prevent small fluctuations or market manipulation from destabilizing Melmint. As long as the market expects Melmint to eventually defend the peg, the market will likely immediately restore deviations from the peg.\nWe choose this approach rather than trying to use something like a 24-hour TWAP to get a manipulation-proof price feed and taking immediate action because the latter just makes manipulating the TWAP have a huge payoff, since misleading Melmint will cause immediate, catastrophic action.\nMinting DOSC DOSC minting is also done through coin transmutation. DoscMint transactions must have one output only. A second output will be synthesized in the next block with the appropriate reward.\nDiscussion Why is Melmint v2 better? Melmint v2\u0026rsquo;s design is better because:\n It is less intrusive to implement. We don\u0026rsquo;t introduce exceptions left and right to the core transaction validation logic. Instead, \u0026ldquo;coin transmutation\u0026rdquo; when the block is sealed implements all Melmint-related actions. Logic for transmuting coins can be implemented once and reused. It provides a general fallback DEX. This DEX is unlikely to become dominant on Themelio, especially as layer-2 solutions mature, but it nevertheless will provide a secure source of approximate market prices that always works. It\u0026rsquo;s much simpler conceptually, largely because it gets rid of the the two most complicated procedures in Melmint: sym auction and recovery. It\u0026rsquo;s most likely far more robust because it does not require complicated auction rules or hardcoded depegging mechanisms. Instead, it relies on the well-studied, battle-tested robustness of constant-product AMMs and a market-based depegging mechanism that we will discuss in the next section.  Market-based depegging One notable feature in Melmint v2 is that the mel\/sym pool is not directly funded by printing mels\/syms out of thin air. Instead, the strength of Melmint\u0026rsquo;s monetary policy \u0026ldquo;lever\u0026rdquo; is decided entirely by market participants\u0027 individual decisions to contribute to the mel\/sym liquidity pool.\nThis is important, because it actually avoids a failure scenario in Melmint v1. In v1, unless an arbitrary depegging threshold is used, a \u0026ldquo;death spiral\u0026rdquo; can form where a sudden loss of confidence in the mel causes a run on the mel as people rush to convert them into syms at an above-market price, which then hyperinflates the syms, causing even more loss of confidence in the mel, etc.\nIn v2, however, such a spiral cannot happen, because when there is a whiff of sym hyperinflation-induced systemic collapse, the immediate response of any rational sym holder would be to remove liquidity from the sym\/mel pool to \u0026ldquo;cash out\u0026rdquo; as fast as possible. This rapidly disables Melmint\u0026rsquo;s monetary policy.\nFurthermore, each marginal withdrawal marginally weakens Melmint, so there\u0026rsquo;s no pressure to be the \u0026ldquo;first in line\u0026rdquo; to withdraw.\nThus, Melmint is inherently run-proof the way properly priced money-market mutual funds, as opposed to bank accounts, are run-proof.\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/tech-melmint\/"
              },
              
              {
                value: "Melmint: trustless stable cryptocurrency",
                label: "<p>Note: this is a minimally revised version of a paper we published at CryptoEconSys 2020\nDecentralized cryptocurrencies have gathered increasing interest in the past few years, raising hopes of a new era of non-sovereign electronic money. Unfortunately, cryptocurrencies perform poorly as actual money due to their unacceptably volatile purchasing power. \u0026ldquo;Stablecoins\u0026rdquo; aiming to reduce this volatility, on the other hand, tend to peg to an external currency like the US dollar, gravely weakening the decentralization that makes cryptocurrencies so attractive.\nMelmint is a mechanism for issuing a trustlessly stable cryptocurrency, Mel, designed for the prototype Themelio blockchain but easily portable to others. Mel is defined without any reference to external pegs such as the US dollar, eliminating the need for oracles and other trusted third parties. This solves a major open problem in the field. We use Elasticoin, an existing proposal to reduce cryptocurrency volatility, as a building block for a trustless monetary policy that gives Mel robustly stable purchasing power. We evaluate Melmint through both theoretical economic arguments and stochastic market simulation, an approach not seen in the existing literature. In all our tests, Melmint is shown to be exceptionally robust in both mundane and extreme economic conditions.\nRead full PDF\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/whitepapers\/melmint\/"
              },
              
              {
                value: "Melnet specification (WIP)",
                label: "<p>Melnet is an almost trivial request\/response protocol that underpins Themelio\u0026rsquo;s peer-to-peer network.\nBasic semantics Each peer-to-peer network is identified with a netname, which is sent with all requests.\nThe only kind of communication pattern is a simple request-response, which is sent over a TCP connection. The way the connection is used is similar to HTTP\/1.1: the client sends a request over a connection, waiting for the response before sending another one. Parallel requests are done by opening multiple connections, and connection pooling should be used to save resources.\nIn a single request-response roundtrip:\n The request contains a verb, a string representing a RPC function call (say, send_tx), as well as arbitrary bytes representing the body. These bytes conventionally represent a value bincode-encoded the same way as Themelio state elements are. This is represented by the following bincode-encoded structure: pub struct RawRequest { pub proto_ver: u8, pub netname: String, pub verb: String, pub payload: Vec\u0026lt;u8\u0026gt;, } which is sent over the wire preceded by its encoded length, as a 32-bit (4-byte) big-endian number.\n The response is a bincode-encoded structure: pub struct RawResponse { pub kind: String, pub body: Vec\u0026lt;u8\u0026gt;, } which is also sent as a length-prefixed value. Here, kind is one of:\n \u0026quot;Ok\u0026quot;, indicating success. body will contain the response to the RPC call. \u0026quot;NoVerb\u0026quot;, indicating that no such verb exists. \u0026quot;Err\u0026quot;, indicating an error. body will contain a descriptive UTF-8 string.    Establishing a broadcast mesh </p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/melnet-spec\/"
              },
              
              {
                value: "MelVM: low-level covenant VM ",
                label: "<p>Overview MelVM is the low-level, stack-based virtual machine that powers Themelio covenants. By only allowing looping for a fixed number of iterations, MelVM makes the worst-case cost of each covenant computable, trading off Turing completeness. Unlike Bitcoin scripts, however, MelVM covenants can compute all primitive recursive functions, allowing expressing almost all \u0026ldquo;interesting\u0026rdquo; constructs.\nMemory model MelVM uses a Harvard architecture where the code itself is not part of the memory space. Memory is divided into two regions: the stack and the heap. Except when data is transferred between the stack and the heap, MelVM instructions directly operate only on stack data, pushing and popping items from the top of the stack.\nA big difference from most low-level VMs is that the basic unit of data isn\u0026rsquo;t a word of binary data, but a recursive data structure:\npub enum Value { Int(U256), Bytes(im::Vector\u0026lt;u8\u0026gt;), Vector { members: im::Vector\u0026lt;Value\u0026gt;, is_struct: bool }, } That is, there are two base types:\n 256-bit unsigned integers Arbitrary-length bytestrings  As well as two product types:\n Vectors, with is_struct = false, semantically represent homogenous vectors such as lists of signatures Structs, with is_struct = true, semantically represent fixed-length structures such as transactions  The stack is just a FIFO stack of Values, while the heap is a mapping from 16-bit addresses to Values.\nExecution model MelVM takes as input:\n An initial stack consisting of two items:  On the very top, the spending transaction Underneath it, a custom input (e.g. an index indicating which signature spends the coin)   An initial heap consisting of the following items:  Addr 0x10: the fully decoded previous block header (e.g. if the covenant is spent in block 100, this is header 99) Addr    List of opcodes In the \u0026ldquo;meaning\u0026rdquo; field, all expressions are evaluated left to right. For example, pop() - pop() means pop a value x, then another value y, and then compute x-y.\nArithmetic Overflow always wraps. Whether or not the previous instruction overflowed can be queried.\n   Opcode Encoding Meaning     ADD 0x10 push(pop() \u002b pop())   SUB 0x11 push(pop() - pop())   MUL 0x12 push(pop() * pop())   DIV 0x13 push(pop() \/ pop())   REM 0x14 push(pop() % pop())   OFLO 0x15 push(overflowed ? 1 : 0)    Logic All operators operate on integers and are bitwise.\n   Opcode Encoding Meaning     AND 0x20 push(pop() \u0026amp; pop())   OR 0x21 push(pop() | pop())   XOR 0x22 push(pop() ^ pop())   NOT 0x23 push(~pop())    Cryptography Operators take in a bytestring and return a bytestring.\n   Opcode Encoding Meaning     HASH(n) 0x30 \u002b u16be push(blake3(pop()[..n]))   SIGEOK(n) 0x32 \u002b u16be push(ed25519_verify(msg = pop()[..n], pk = pop(), sig = pop()))    Heap access    Opcode Encoding Meaning     LOAD 0x40 push(heap[pop()])   STORE 0x41 heap[pop()] = pop()    Vectors Despite their appearance, these operations, as well as those for bytestrings, are all quasi-constant-time because vectors and bytestrings can be represented as RRB trees or similar.\n   Opcode Encoding Meaning     VEMPTY 0x50 push(empty vector)   VREF 0x51 push(pop()[pop()])   VLENGTH 0x52 push(pop().length)   VAPPEND 0x53 push(pop() \u002b\u002b pop())   VPUSH 0x54 push(pop().push(pop()))   VSLICE 0x55 push(pop[pop()..pop()])    Bytestrings    Opcode Encoding Meaning     BEMPTY 0x60 push(empty bytestring)   BREF 0x61 push(pop()[pop()])   BLENGTH 0x62 push(pop().length)   BAPPEND 0x63 push(pop() \u002b\u002b pop())   BPUSH 0x64 push(pop().push(pop()))   BSLICE 0x65 push(pop[pop()..pop()])    Control flow    Opcode Encoding Meaning     JMP(n) 0xa0 Jump n instructions forward   BEZ(n) 0xa1 If pop() is zero, jump n   BNZ(n) 0xa2 If pop() isn\u0026rsquo;t zero, jump n   LOOP(n, body) 0xb0 \u002b u16be \u002b u16be Loop body n times    Type conversions    Opcode Encoding Meaning     ITOB 0xc0 Pops an integer and converts to bytes   BTOI 0xc1 Pops bytes and converts first 32B to integer   SERIAL(n) 0xd0 Serialize with \u0026ldquo;weight limit\u0026rdquo;. If more than n nodes are visited abort.   DESERIAL(n) 0xd1 Bincode-deserialize with length limit.    Literals    Opcode Encoding Meaning     PUSHB(bytes) 0xf0 \u002b u8 length \u002b bytes Push the bytes to the stack   PUSHI(int) 0xf1 \u002b u256be Push the integer to the stack    </p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/melvm-specification\/"
              },
              
              {
                value: "Specifications",
                label: "<p></p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/"
              },
              
              {
                value: "MelScript: high-level covenant language (WIP)",
                label: "<p>The high-level MelScript language is essentially an extension of simply typed lambda calculus, packaged in a friendly syntax.\nStructure of a MelScript covenant A MelScript covenant consists of zero or more definitions followed by a single expression. Each definition itself follows an analogous structure.\nHere\u0026rsquo;s an example that constraints a coin to only be spent in a transaction whose total output in micromels is odd, and has less than 16 outputs:\nusing globals::CURRENT_TX using std function total_output[$OCOUNT]() -\u0026gt; Nat CURRENT_TX.outputs |\u0026gt; limit[$OCOUNT]() |\u0026gt; filter((coin: std::TxOutput) =\u0026gt; coin.coin_type == std::TMEL) |\u0026gt; map((coin: std::TxOutput) =\u0026gt; coin.value) end total_output[$16]() % 2 == 1 MelScript\u0026rsquo;s type system MelScript uses a type system heavily based on \u0026ldquo;const generics\u0026rdquo; to enable richly-featured programming with compile-time-determined runtime cost. The type system is fundamentally structural, and types can be completely understood as describing sets of values. Parametric polymorphism (\u0026ldquo;generics\u0026rdquo;) is supported, implemented entirely by monomorphization (\u0026ldquo;templates\u0026rdquo;) after typechecking, like Rust and unlike C\u002b\u002b.\nBase types There are four base types:\n Nat, representing an unsigned 256-bit integer Int, representing a signed 256-bit integer Bool, representing a boolean Bytes[$N], a const-generic type representing a byte array with exactly N elements. VarBytes[$N], a const-generic type representing a byte array with at most N elements. VarBytes[$N] is a supertype of Bytes[$N]  Product types There are three kinds of product types:\n Tuples, written as (T, U, V...). They are fixed-length, and elements can be accessed as tuple.0 etc. Arrays, written as Array[T; $N] representing a fixed-length array of exactly N elements, all of type T. Variable-length arrays, written as VarArray[T; $N], representing an array that has up to N elements. VarArray[T; $N] is a supertype of Array[T; $N].  Sum types A sum type between T and U is denoted as T\u002bU. For example, a value with type Nat \u002b (Int, Int) may either be an unsigned integer or a tuple of two signed integers.\nThe special type Any essentially denotes a type that could be any type.\nSum types can be disambiguated through conditionals and the is operator:\n-- if v is an integer, return itself -- otherwise return 0 function force_to_int(v: Any) -\u0026gt; Int if v is Int then v else 0 end end Subtraction types A subtraction type between T and U is denoted as T \\ U. This denotes a value that is in type T but not in type U.\nFor example, a value with type Int \\ Nat must be a negative integer.\nType aliases Type aliases give a name to a complex type so that type signatures don\u0026rsquo;t become extremely cumbersome to type.\nSimple aliases -- Point is just another name for (Int, Int) alias Point = (Int, Int) Struct aliases Struct aliases have special behavior: they allow field-accessor syntax that can be used whenever a variable is explicitly given a particular alias. This exception to purely structural typing allows us to define semantically distinct structures:\n-- Point is essentially equivalent to (Int, Int), but with a field-accessor syntax alias Point = { x: Int, y: Int, } -- syntax examples let pt = Point { x: 3, y: 5 } pt.x -- \u0026#34;struct\u0026#34; syntax pt.0 -- but this still works (1, 5) is Point -- but this returns true -- and we can do this let pp = (1, 5) if pp is Point then pp.x else 0 end Occurrence typing In previous examples, we\u0026rsquo;ve already seen MelScript\u0026rsquo;s occurrence typing in action. The type of a variable may be refined within a certain scope based on predicates.\nThe simplest example is the is operator that returns true iff the argument is a certain type:\nlet foo: Int | (Nat, Nat) = ... -- at this point, foo has type \u0026#34;Int | (Nat, Nat)\u0026#34; if foo is Int then -- now, foo has type \u0026#34;Int\u0026#34; foo \u002b 1 else -- we know that here foo could only be of type \u0026#34;(Nat, Nat)\u0026#34; foo.0 \u002b 1 We can also use assert to assert that something is a certain type, aborting the whole script if it fails:\nlet foo: Int = ... -- this is only defined for positive integers. Nat is a subtype of Int int_sqrt(assert foo as Nat) Syntax Arithmetic expressions We use the usual infix syntax\nx \u002b y -- addition x * y -- multiplication x - y -- subtraction x \/ y -- integer division x % y -- remainder -x -- negation -- bitwise operations only on Nat x ^ y -- bitwise xor. NOT exponentiation, which wouldn\u0026#39;t be constant-time x | y -- bitwise or x \u0026amp; y -- bitwise and ~x -- bitwise not Boolean expressions Boolean expressions are short-circuited as expected.\nx and y x or y not x Looping and flow control The if form is an expression:\nlet foo = if bar then baz else nuu end The for..do form is a statement (an expression with type ()), and is run for its side effects:\nfor elem in list do if elem % 2 == 0 then return elem else end The for..collect..where form collects its contents into a list:\nlet even_elems = for elem in list collect elem where elem % 2 == 0 end Defining functions Functions are defined like this:\nfunction f(x: Int, y: Int) -\u0026gt; Int ... end MelScript does not at the moment support higher-order functions or anonymous functions.\nModules Each module corresponds to a file.\nSomething is exported by prepending its definition by public:\npublic function... public type ... Importing another module uses the using keyword. Local files can be used too.\nusing std using \u0026#34;some_file\u0026#34; as sfile -- creates namespace sfile::* in this file </p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/melscript-specification\/"
              },
              
              {
                value: "Fastsync protocol",
                label: "<p>The fastsync protocol is used by both stakers and auditors to catch up to the latest confirmed SealedState without starting from the genesis block and applying block after block.\nThis is done through a two-step process:\n The \u0026ldquo;catcher-up\u0026rdquo; does a InitFastSync request. The server responds with a host:port where the fastsync protocol will be run. The catcher-up connects to host:port over TCP and initiates the fastsync protocol. This consists of the server serializing the entire state and streaming it, while the client receives.  Serializing a SealedState Serialization of a sealed state is rather straightforward. First, the Header is sent over the wire. Then, each SmtMapping is serialized.\nHow do we serialize a SmtMapping? We simply traverse the entire SMT from left to right, sending over\npub struct SmtEntry { value: Vec\u0026lt;u8\u0026gt;, proof: CompressedProof } one after the other.\nThe receiver, for its part, checks each proof against the header and gradually builds a SMT.\nCompression One potential problem is that the Merkle proofs take up a lot of space in each entry. Fortunately, adjacent Merkle proofs are generally very similar, so we can simply apply encapsulate the entire stream in DEFLATE. This should take care of compressing away the redundancies.\n</p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/fastsync\/"
              },
              
              {
                value: "Glossary",
                label: "<p>State elements constitute the components of the world state\n Blocks are defined by their constituent transactions, optionally with a consensus proof Consensus proofs are attached to blocks, turning them into confirmed blocks. The world state contains history and coin state   Each transaction has:\n Transaction inputs, each of which spends a coin (mapping in the coin state) by unlocking its covenant Transaction outputs, each of which has a value, a denomination, and a MelVM covenant Attached data   Currencies:\n The base currency is \u0026ldquo;Mel\u0026rdquo; and the unit is \u0026ldquo;mel\u0026rdquo;. This is like \u0026ldquo;Bitcoin\u0026rdquo; vs \u0026ldquo;bitcoin\u0026rdquo;.  We accept Mel, Bitcoin, and other cryptocurrencies. The burger cost 4 mels   Decimal SI prefixes can be used.  A burger and a side of fries costs 6 mels and 33 centimels. The smallest unit of money on Themelio is 1 micromel.   Sym and syms is similar. Actual usage that emerges will probably be different and will be \u0026ldquo;correct\u0026rdquo;.   Algorithms:\n The PoS system as a whole is Synkletos. Symphonia is an internal name referring to a particular implementation of non-pipelined HotStuff. It\u0026rsquo;s not really an \u0026ldquo;official\u0026rdquo; part of Themelio\u0026rsquo;s definition. Melmint is the cryptocurrency issuance mechanism. It\u0026rsquo;s not a currency.  In the last week Melmint minted a record 3 megamels onto the Themelio blockchain, half of which were locked up and reissued as ERC-20 tokens.    </p><p></p>",
                url: "https:\/\/docs.themelio.org\/specifications\/glossary\/"
              },
              
              {
                value: "Themelio Knowledge Base",
                label: "<p></p>",
                url: "https:\/\/docs.themelio.org\/"
              },
              
              {
                value: "Categories",
                label: "<p></p>",
                url: "https:\/\/docs.themelio.org\/categories\/"
              },
              
              {
                value: "Tags",
                label: "<p></p>",
                url: "https:\/\/docs.themelio.org\/tags\/"
              },
              
            ];
            $("#search").autocomplete({
              source: projects
            })
              .data("ui-autocomplete")._renderItem = function (ul, item) {
                return $("<li>")
                  .append("<a href=" + item.url + " + \" &quot;\" +  >" + item.value + "</a>" + item.label)
                  .appendTo(ul);
              };
            });
          </script>
        </div>
      </ul>
    </div>
  </div>
</nav>

    </header>
    <!-- /header -->
    
    

<!-- details page -->
<section class="single section-sm pb-0">
  <div class="container">
    <div class="row">
      <div class="col-lg-3">
        <ul class="sidebar">
          
          
          
          









<li data-nav-id="https://docs.themelio.org/table-of-contents/" title="Themelio overview" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/table-of-contents/">
    Themelio overview 
  </a>
  
</li>



          
          









<li data-nav-id="https://docs.themelio.org/whitepapers/" title="Whitepapers" class="sidelist
  ">
  
  <span class="navsection">
    Whitepapers 
  </span>
  <ul class="col-lg-12">
    
    
    









<li data-nav-id="https://docs.themelio.org/whitepapers/themelio/" title="Themelio: a stable blockchain for an unstable world" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/whitepapers/themelio/">
    Themelio: a stable blockchain for an unstable world 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/whitepapers/synkletos/" title="Synkletos: Themelio&#39;s collusion-resistant consensus mechanism" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/whitepapers/synkletos/">
    Synkletos: Themelio&#39;s collusion-resistant consensus mechanism 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/whitepapers/melmint/" title="Melmint: trustless stable cryptocurrency" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/whitepapers/melmint/">
    Melmint: trustless stable cryptocurrency 
  </a>
  
</li>



    
    
  </ul>
  
</li>



          
          









<li data-nav-id="https://docs.themelio.org/try-themelio/" title="Try Themelio" class="sidelist
  ">
  
  <span class="navsection">
    Try Themelio 
  </span>
  <ul class="col-lg-12">
    
    
    









<li data-nav-id="https://docs.themelio.org/try-themelio/alphanet-client/" title="My first alphanet transaction" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/try-themelio/alphanet-client/">
    My first alphanet transaction 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/try-themelio/auditor-node/" title="Running an auditor node" class="sidelist
  active">
  
  <a href="https://docs.themelio.org/try-themelio/auditor-node/">
    Running an auditor node 
  </a>
  
</li>



    
    
  </ul>
  
</li>



          
          









<li data-nav-id="https://docs.themelio.org/specifications/" title="Specifications" class="sidelist
  ">
  
  <span class="navsection">
    Specifications 
  </span>
  <ul class="col-lg-12">
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/yellow/" title="Themelio Yellow Paper v1" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/yellow/">
    Themelio Yellow Paper v1 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/consensus-spec/" title="Consensus specification (WIP)" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/consensus-spec/">
    Consensus specification (WIP) 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/tech-melmint/" title="Melmint v2 specification (WIP)" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/tech-melmint/">
    Melmint v2 specification (WIP) 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/melnet-spec/" title="Melnet specification (WIP)" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/melnet-spec/">
    Melnet specification (WIP) 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/melvm-specification/" title="MelVM: low-level covenant VM " class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/melvm-specification/">
    MelVM: low-level covenant VM  
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/melscript-specification/" title="MelScript: high-level covenant language (WIP)" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/melscript-specification/">
    MelScript: high-level covenant language (WIP) 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/fastsync/" title="Fastsync protocol" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/fastsync/">
    Fastsync protocol 
  </a>
  
</li>



    
    
    
    









<li data-nav-id="https://docs.themelio.org/specifications/glossary/" title="Glossary" class="sidelist
  ">
  
  <a href="https://docs.themelio.org/specifications/glossary/">
    Glossary 
  </a>
  
</li>



    
    
  </ul>
  
</li>



          
        </ul>
      </div>
      <div class="col-lg-6 col-xl-6">
        <div class="p-lg-5 p-4 bg-white">
          <h1 class="mb-1">Running an auditor node</h1>
          
          <hr />
          <div class="content"><h1 id="running-an-auditor-node">Running an auditor node</h1>
<p>This document will guide you through setting up an <strong>auditor</strong>, which is the equivalent of a <strong>full node</strong> in most other blockchains. An auditor replicates every consensus-confirmed block, validating its contents and ensuring network security while providing a local cache of the entire blockchain state.</p>
<h2 id="assumptions">Assumptions</h2>
<p>All the instructions here assume that you have an up-to-date <code>themelio-core</code> binary installed. If not, simply install it with <code>cargo</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cargo install --git https://github.com/themeliolabs/themelio-core.git
</code></pre></div><h2 id="running-the-auditor">Running the auditor</h2>
<p>To run an auditor, just run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ themelio-core anet-node --bootstrap 94.237.109.116:11814
</code></pre></div><p>You should see output similar to the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Dec 29 20:47:55.627  INFO run_main:run_node: themelio_core: themelio-core v0.1.0 initializing...    
Dec 29 20:47:55.627  INFO run_main:run_node: themelio_core: bootstrapping with [94.237.109.116:11814]    
Dec 29 20:47:55.627  INFO run_main:run_node:open_testnet{path=&#34;/tmp/testnet&#34;}: themelio_core::storage: creating a testnet genesis state from scratch    
Dec 29 20:47:56.526 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 0 with 0 transactions    
Dec 29 20:47:56.526 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block special case when height is zero    
Dec 29 20:47:56.527 DEBUG blksync_loop:apply_block: themelio_core::storage: block 0, txcount=0, hash=#&lt;f8dbd36a0f&gt; APPLIED    
Dec 29 20:47:57.377 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 1 with 0 transactions    
Dec 29 20:47:57.377 DEBUG blksync_loop:apply_block: themelio_core::storage: block 1, txcount=0, hash=#&lt;c2182ca753&gt; APPLIED    
Dec 29 20:47:58.379 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 2 with 0 transactions    
Dec 29 20:47:58.380 DEBUG blksync_loop:apply_block: themelio_core::storage: block 2, txcount=0, hash=#&lt;d741c12dcc&gt; APPLIED    
Dec 29 20:47:59.336 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 3 with 0 transactions    
Dec 29 20:47:59.337 DEBUG blksync_loop:apply_block: themelio_core::storage: block 3, txcount=0, hash=#&lt;f6a0829cd2&gt; APPLIED    
Dec 29 20:48:00.285 DEBUG blksync_loop:apply_block: themelio_core::storage: apply_block at height 4 with 0 transactions    

</code></pre></div><p>Your auditor is now running and replicating blocks within the auditor peer-to-peer gossip network.</p>
<p><strong>Note</strong>: right now the auditor implementation is not very useful, since not much happens in the network that&rsquo;s interesting to replicate!</p>
<h2 id="connecting-a-client-to-the-auditor">Connecting a client to the auditor</h2>
<p>One of the most common uses of a local auditor node is to connect to a thin client in order to free the thin client from depending on a remote server for availability and latency. Try <a href="alphanet-client.md">following the alphanet client tutorial</a>, except by running</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">themelio-core anet-client --bootstrap 127.0.0.1:11814
</code></pre></div></div>
          
          <nav class="pagination mt-3">
            
            
            
            
            
            
            
            
            
            

            
            
            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            
            

            
            
            

            
            
            
            
            
            
            
            
            
            

            
            <a class="nav nav-prev" href="https://docs.themelio.org/try-themelio/alphanet-client/"><i class="ti-arrow-left mr-2"></i> <span class="d-none d-md-block">My first alphanet transaction</span></a>
            
            
            <a class="nav nav-next" href="https://docs.themelio.org/specifications/"> <span class="d-none d-md-block">Specifications</span><i class="ti-arrow-right ml-2"></i></a>
            
          </nav>
        </div>
      </div>
      <div class="d-none d-lg-block col-lg-3">
        <div id="toc-container"><nav id="TableOfContents">
  <ol>
    <li><a href="#running-an-auditor-node">Running an auditor node</a>
      <ol>
        <li><a href="#assumptions">Assumptions</a></li>
        <li><a href="#running-the-auditor">Running the auditor</a></li>
        <li><a href="#connecting-a-client-to-the-auditor">Connecting a client to the auditor</a></li>
      </ol>
    </li>
  </ol>
</nav></div>
      </div>
    </div>
  </div>
</section>
<!-- /details page -->










    <!-- footer -->
<footer class="section pb-4">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-8 text-md-left text-center">
       <p class="mb-md-0 mb-4">Copyright © 2020 Themelio Labs (<a href="https://themelio.org/">https://themelio.org/</a>)</p>
      </div>
      <div class="col-md-4 text-md-right text-center">
        <ul class="list-inline">
          
          <li class="list-inline-item"><a class="text-color d-inline-block p-2" href="#"><i class="ti-twitter-alt"></i></a></li>
          
          <li class="list-inline-item"><a class="text-color d-inline-block p-2" href="#"><i class="ti-github"></i></a></li>
          
          <li class="list-inline-item"><a class="text-color d-inline-block p-2" href="#"><i class="ti-linkedin"></i></a></li>
          
        </ul>
      </div>
    </div>
  </div>
</footer>
<!-- /footer -->

<!-- Main Script -->

<script src="https://docs.themelio.org/js/script.min.js"></script>
<script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
           extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
    });
    MathJax.Hub.Queue(function() {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });

    MathJax.Hub.Config({
    
    TeX: { equationNumbers: { autoNumber: "AMS" } },
    "HTML-CSS": {
      scale: 90
    }
    });
  </script>
  </body>

</html>